#!/bin/bash

dir=/Users
pname_filter='    /* off */'
pid_filter='    /* off */'
ignore_pname_filters='    /* off */'
exclude_pid_filter='    /* off */'
opt_verbose=0
opt_test=0

while getopts n:p:x:i:dvt name
do
    case $name in
        n) pname_filter="    (execname == \"$OPTARG\") ? self->ok = 1 : 1;";;
        p) pid_filter="    (pid == $OPTARG) ? self->ok = 1 : 1;";;
        x) exclude_pid_filter="    (pid == $OPTARG) ? self->ok = 0 : 1;";;
        i)
            IFS=',' read -r -a pnames <<< "$OPTARG";
            ignore_pname_filters=''
            for p in ${pnames[@]}; do
                ignore_pname_filters+="    (\"$p\" == execname) ? self->ok = 0 : 1;"$'\n'
            done;;
        d) [[ $OPTARG = /* ]] && dir=$OPTARG || dir=$PWD/${OPTARG#./};;
        v) opt_verbose=1;;
        t) opt_test=1;;
        h|?) cat <<EOF >&2
USAGE: $0 [-p PID] [-n name]
        -v         # verbose
        -t         # test-only: shows the generated dtrace script, will not run
        -d DIR     # sniffer events under this dir only
        -p PID     # this PID only
        -x PID     # exclude this PID
        -n name    # this process name only
        -i names   # ignore a list of execnames (separated by commas)
For example,
    $0 -p 1234  # only sniff events from PID 1234
    $0 -x 1234  # exclude PID 1234
    $0 -n Python  # only sniff events from Python
    $0 -i Evernote,mdworker  # ignore Evernote and mdworker
EOF
        exit 1
    esac
done

dtrace='
/*
* Command line arguments
*/
inline int DIR_LEN          = '$(echo -n "$dir" | wc -c)';
inline string DIR           = "'$dir'";

syscall::*open_nocancel:entry,
syscall::*read_nocancel:entry,
syscall::*write_nocancel:entry,
syscall::close_nocancel:entry,
syscall::getdirentries*:entry,
syscall::*read:entry,
syscall::*write:entry,
syscall::close:entry,
syscall::unlink:entry
{
    self->ok = 1;

    /* Process name filter */
'$pname_filter'

    /* Only this PID */
'$pid_filter'

    /* Whitelist filters: ignore those processes */
'$ignore_pname_filters'

    /* Exclude PID */
'$exclude_pid_filter'
}

syscall::open*:entry
/self->ok/
{
    self->path = copyinstr(arg0);

    /* Extension checking
    this->idx = rindex(self->path, ".");
    self->ext = (this->idx >= 0) ? substr(self->path, this->idx) : "";
    strlen(self->ext) > 0 ? self->ext = substr(self->ext, 1) : "";

    (self->ext == "png") ? (self->ok = 1) : (self->ok = 0);
    */
}

syscall::open*:return
/self->ok &&
 arg1 > 2 &&
 self->path != "" &&
 (substr(self->path, 0, 1) != "/" || substr(self->path, 0, DIR_LEN) == DIR)/
{
    /* Check if path is our watched dir */
    /*
    (self->path != "" &&
        (substr(self->path, 0, 1) != "/" ||
        substr(self->path, 0, DIR_LEN) == DIR)
    ) ? printf("{\"action\": \"open\", \"pid\": %d, \"path\": \"%s\", \"fd\": %d, \"t\": \"%-20Y\"}\n", pid, self->path, arg1, walltimestamp) : printf("");
    */

    printf("{\"action\": \"open\", \"pid\": %d, \"path\": \"%s\", \"fd\": %d, \"t\": \"%-20Y\"}\n", pid, self->path, arg1, walltimestamp);

    /* Apple crippled dtrace so that fi_pathname shows "??/..."
    self->fd_path[arg1] = substr(self->path, 0, 1) == "/" ? self->path : stringof(fds[arg1].fi_pathname);
    */
    self->fd_path[arg1] = self->path;

    self->path = 0;
}

syscall::unlink:entry
/self->ok &&
 self->fd_path[arg0] != "" &&
 (substr(self->fd_path[arg0], 0, 1) != "/" || substr(self->fd_path[arg0], 0, DIR_LEN) == DIR)/
{
    printf("{\"action\": \"unlink\", \"pid\": %d, \"path\": \"%s\", \"t\": \"%-20Y\"}\n",
            pid, copyinstr(arg0), walltimestamp);
}

syscall::getdirentries*:entry
/self->ok &&
 self->fd_path[arg0] != "" &&
 (substr(self->fd_path[arg0], 0, 1) != "/" || substr(self->fd_path[arg0], 0, DIR_LEN) == DIR)/
{
    printf("{\"action\": \"listdir\", \"pid\": %d, \"fd\": %d, \"path\": \"%s\", \"t\": \"%-20Y\"}\n",
            pid, arg0, self->fd_path[arg0], walltimestamp);
}

syscall::read*:entry
/self->ok &&
 arg0 > 2 &&
 self->fd_path[arg0] != "" &&
 (substr(self->fd_path[arg0], 0, 1) != "/" || substr(self->fd_path[arg0], 0, DIR_LEN) == DIR)/
{
    printf("{\"action\": \"read\", \"pid\": %d, \"fd\": %d, \"path\": \"%s\", \"size\": %d, \"t\": \"%-20Y\"}\n",
            pid, arg0, self->fd_path[arg0], arg2, walltimestamp);
}

syscall::write*:entry
/self->ok &&
 arg0 > 2 &&
 self->fd_path[arg0] != "" &&
 (substr(self->fd_path[arg0], 0, 1) != "/" || substr(self->fd_path[arg0], 0, DIR_LEN) == DIR)/
{
    printf("{\"action\": \"write\", \"pid\": %d, \"fd\": %d, \"path\": \"%s\", \"size\": %d, \"t\": \"%-20Y\"}\n",
            pid, arg0, self->fd_path[arg0], arg2, walltimestamp);
}

syscall::close*:entry
/self->ok &&
 arg0 > 2 &&
 self->fd_path[arg0] != "" &&
 (substr(self->fd_path[arg0], 0, 1) != "/" || substr(self->fd_path[arg0], 0, DIR_LEN) == DIR)/
{
    printf("{\"action\": \"close\", \"pid\": %d, \"fd\": %d, \"path\": \"%s\", \"t\": \"%-20Y\"}\n",
            pid, arg0, self->fd_path[arg0], walltimestamp);
}
'

if [ $opt_test -eq 1 ]; then
    echo "$dtrace"
elif [ $opt_verbose -eq 1 ]; then
    sudo dtrace -q -n "$dtrace" 2>/dev/null
else
    sudo dtrace -q -n "$dtrace"
fi
